/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


#pragma mark - NativeCameraRollModuleAlbum

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeCameraRollModuleAlbum {
  P0 id{};
  P1 title{};
  P2 count{};
  P3 type{};
  P4 subtype;
  bool operator==(const NativeCameraRollModuleAlbum &other) const {
    return id == other.id && title == other.title && count == other.count && type == other.type && subtype == other.subtype;
  }
};

template <typename T>
struct NativeCameraRollModuleAlbumBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.count)>(rt, value.getProperty(rt, "count"), jsInvoker),
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.subtype)>(rt, value.getProperty(rt, "subtype"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }
  static double countToJs(jsi::Runtime &rt, decltype(types.count) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::String subtypeToJs(jsi::Runtime &rt, decltype(types.subtype) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "title", bridging::toJs(rt, value.title, jsInvoker));
    result.setProperty(rt, "count", bridging::toJs(rt, value.count, jsInvoker));
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    if (value.subtype) {
      result.setProperty(rt, "subtype", bridging::toJs(rt, value.subtype.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeCameraRollModulePhotoIdentifier

template <typename P0>
struct NativeCameraRollModulePhotoIdentifier {
  P0 node;
  bool operator==(const NativeCameraRollModulePhotoIdentifier &other) const {
    return node == other.node;
  }
};

template <typename T>
struct NativeCameraRollModulePhotoIdentifierBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.node)>(rt, value.getProperty(rt, "node"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object nodeToJs(jsi::Runtime &rt, decltype(types.node) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "node", bridging::toJs(rt, value.node, jsInvoker));
    return result;
  }
};



#pragma mark - NativeCameraRollModulePhotoIdentifiersPage

template <typename P0, typename P1, typename P2>
struct NativeCameraRollModulePhotoIdentifiersPage {
  P0 edges{};
  P1 page_info{};
  P2 limited;
  bool operator==(const NativeCameraRollModulePhotoIdentifiersPage &other) const {
    return edges == other.edges && page_info == other.page_info && limited == other.limited;
  }
};

template <typename T>
struct NativeCameraRollModulePhotoIdentifiersPageBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.edges)>(rt, value.getProperty(rt, "edges"), jsInvoker),
      bridging::fromJs<decltype(types.page_info)>(rt, value.getProperty(rt, "page_info"), jsInvoker),
      bridging::fromJs<decltype(types.limited)>(rt, value.getProperty(rt, "limited"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Array edgesToJs(jsi::Runtime &rt, decltype(types.edges) value) {
    return bridging::toJs(rt, value);
  }
  static jsi::Object page_infoToJs(jsi::Runtime &rt, decltype(types.page_info) value) {
    return bridging::toJs(rt, value);
  }
  static bool limitedToJs(jsi::Runtime &rt, decltype(types.limited) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "edges", bridging::toJs(rt, value.edges, jsInvoker));
    result.setProperty(rt, "page_info", bridging::toJs(rt, value.page_info, jsInvoker));
    if (value.limited) {
      result.setProperty(rt, "limited", bridging::toJs(rt, value.limited.value(), jsInvoker));
    }
    return result;
  }
};


template <typename T>
class JSI_EXPORT NativeCameraRollModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNCCameraRoll";

protected:
  NativeCameraRollModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeCameraRollModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["saveToCameraRoll"] = MethodMetadata {.argCount = 2, .invoker = __saveToCameraRoll};
    methodMap_["getPhotos"] = MethodMetadata {.argCount = 1, .invoker = __getPhotos};
    methodMap_["getAlbums"] = MethodMetadata {.argCount = 1, .invoker = __getAlbums};
    methodMap_["deletePhotos"] = MethodMetadata {.argCount = 1, .invoker = __deletePhotos};
    methodMap_["getPhotoByInternalID"] = MethodMetadata {.argCount = 2, .invoker = __getPhotoByInternalID};
    methodMap_["getPhotoThumbnail"] = MethodMetadata {.argCount = 2, .invoker = __getPhotoThumbnail};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __saveToCameraRoll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::saveToCameraRoll) == 3,
      "Expected saveToCameraRoll(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::saveToCameraRoll,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __getPhotos(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getPhotos) == 2,
      "Expected getPhotos(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getPhotos,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));
  }

  static jsi::Value __getAlbums(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getAlbums) == 2,
      "Expected getAlbums(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getAlbums,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt));
  }

  static jsi::Value __deletePhotos(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::deletePhotos) == 2,
      "Expected deletePhotos(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::deletePhotos,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt));
  }

  static jsi::Value __getPhotoByInternalID(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getPhotoByInternalID) == 3,
      "Expected getPhotoByInternalID(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getPhotoByInternalID,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __getPhotoThumbnail(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::getPhotoThumbnail) == 3,
      "Expected getPhotoThumbnail(...) to have 3 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::getPhotoThumbnail,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
      count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt));
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeCameraRollModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};


template <typename T>
class JSI_EXPORT NativeCameraRollPermissionModuleCxxSpec : public TurboModule {
public:
  static constexpr std::string_view kModuleName = "RNCCameraRollPermission";

protected:
  NativeCameraRollPermissionModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker) : TurboModule(std::string{NativeCameraRollPermissionModuleCxxSpec::kModuleName}, jsInvoker) {
    methodMap_["checkPermission"] = MethodMetadata {.argCount = 1, .invoker = __checkPermission};
    methodMap_["requestReadWritePermission"] = MethodMetadata {.argCount = 0, .invoker = __requestReadWritePermission};
    methodMap_["requestAddOnlyPermission"] = MethodMetadata {.argCount = 0, .invoker = __requestAddOnlyPermission};
    methodMap_["refreshPhotoSelection"] = MethodMetadata {.argCount = 0, .invoker = __refreshPhotoSelection};
    methodMap_["addListener"] = MethodMetadata {.argCount = 1, .invoker = __addListener};
    methodMap_["removeListeners"] = MethodMetadata {.argCount = 1, .invoker = __removeListeners};
  }
  
private:
  static jsi::Value __checkPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::checkPermission) == 2,
      "Expected checkPermission(...) to have 2 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::checkPermission,  static_cast<NativeCameraRollPermissionModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));
  }

  static jsi::Value __requestReadWritePermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::requestReadWritePermission) == 1,
      "Expected requestReadWritePermission(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestReadWritePermission,  static_cast<NativeCameraRollPermissionModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __requestAddOnlyPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::requestAddOnlyPermission) == 1,
      "Expected requestAddOnlyPermission(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::requestAddOnlyPermission,  static_cast<NativeCameraRollPermissionModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __refreshPhotoSelection(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* /*args*/, size_t /*count*/) {
    static_assert(
      bridging::getParameterCount(&T::refreshPhotoSelection) == 1,
      "Expected refreshPhotoSelection(...) to have 1 parameters");
    return bridging::callFromJs<jsi::Value>(rt, &T::refreshPhotoSelection,  static_cast<NativeCameraRollPermissionModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule));
  }

  static jsi::Value __addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::addListener) == 2,
      "Expected addListener(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::addListener,  static_cast<NativeCameraRollPermissionModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt));return jsi::Value::undefined();
  }

  static jsi::Value __removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
    static_assert(
      bridging::getParameterCount(&T::removeListeners) == 2,
      "Expected removeListeners(...) to have 2 parameters");
    bridging::callFromJs<void>(rt, &T::removeListeners,  static_cast<NativeCameraRollPermissionModuleCxxSpec*>(&turboModule)->jsInvoker_, static_cast<T*>(&turboModule),
      count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber());return jsi::Value::undefined();
  }
};

} // namespace facebook::react
